OS PP3 Report
Elif Ilaria Yurtseven

I had various difficulties with this project in general as it was highly comprehensive of the course material but also took a lot of research to understand and a lot of time to compile. The initial difficulties were about installing the VM. I had a very hard time partitioning my VM I because it is a very meticulous process. Recompiling the kernel is always a different experience as it takes a lot of time and stress because there is a fear of there being errors. And then it took me a while to understand how the code I modify in different files interacts with each other because though there is a lot to think about, once the code works, it is an extremely satisfactory feeling no matter how small the edit seems to be.

In my second system call coding I researched, learnt and implemented the process of getting user input which could be perceived as inspired by the scanf() C library function which calls the read() system call. Though I then used outputted the user input onto the kernel log, which technically is similar to the write() sytem call which is called by the printf() C library function. It was just so exciting so see the endless possibility of ideas even though I was only able to implement very simple ones because it is not a simple process to do all this. 

The functions I am submitting so far are both outputting onto the kernel log because with all the code that there was to modify, I have had to do a lot of research and it seems that these were relatively more convenient to implement. I learnt about what a kernel is and how it works and how many changes are needed in order to create a system call. I learned how to define handlers and how to use dmseg. Dmseg i very interesting to me as the kernel keeps track of everything that is happening in the kernel log. I have been working on another system call which iterates through all processes and outputs onto the kernel log a lot of information. This information consists of the process, process id, process state, priority, rt priority, static priority and normal priority. In order to write this system call I had to research a lot about how priorities work. Not only I researched how priorities are set and how do they work and what do they mean but also how to code them and how to access information about a process. It also turns out that there are different ways to coding system calls. It is possible to define the system calls in their own program in a folder inside the linux-4.14.37 folder and make their own Makefile. Once the makefile is linked to the kernel’s makefile which is in the linux-4.14.37 folder, it is possible to run that system call without having to define the system call handler as long as the system call is added to the system call table. There is a lot of matoculous detail to think about and though it was very demanding I am very satisfied to have pushed through this project because now I have an interest in a brand new, highly complicated part of computer science.

I also learnt that attention to detail is essential in this project because considering how long one change takes to compile and the compilation is consecutive files compiling, there is no real room for mistakes in such coding. 

There was a lot of information to be learnt in this project. I was surprised to find out that there are 17 million lines of code (one the greatest piece of codes in history) and with all the time and effort I have been putting I am barely scratching the surface of all the code. It feels like even if I studied this for years I wouldn’t know everything there is to know about coding a kernel. 
